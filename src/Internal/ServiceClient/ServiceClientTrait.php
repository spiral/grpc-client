<?php

declare(strict_types=1);

namespace Spiral\Grpc\Client\Internal\ServiceClient;

use Google\Protobuf\Internal\Message;
use Spiral\Grpc\Client\Interceptor\Helper;
use Spiral\Grpc\Client\Internal\Connection\ConnectionInterface;
use Spiral\Interceptors\Context\CallContext;
use Spiral\Interceptors\Context\Target;
use Spiral\Interceptors\HandlerInterface;
use Spiral\RoadRunner\GRPC\ContextInterface as RRGrpcContext;

/**
 * Used by Service Clients generated by {@see ClassGenerator::generate()}
 *
 * The trait implements {@see \Spiral\RoadRunner\GRPC\ServiceInterface}
 *
 * @internal
 * @psalm-internal Spiral\Grpc\Client\Internal
 */
trait ServiceClientTrait
{
    /**
     * @param list<ConnectionInterface> $connections
     * @see ServiceClientInterface::__construct()
     */
    public function __construct(
        private readonly array $connections,
        private readonly HandlerInterface $handler,
    ) {}

    /**
     * Run gRPC call through the interceptor pipeline.
     *
     * @param non-empty-string $function
     * @param non-empty-string $returnType
     * @throws \Throwable
     */
    private function _handle(
        string $function,
        RRGrpcContext $ctx,
        Message $in,
        string $returnType,
    ): Message {
        $uri = '/' . static::NAME . '/' . $function;

        /** @see \Spiral\Grpc\Client\Internal\Connection\ClientStub::invoke() */
        $callContext = new CallContext(
            Target::fromClosure($this->_invoke(...)),
            arguments: [
                # Connection
                $this->connections[0],
                # gRPC method
                $uri,
                # Message
                $in,
                # Deserializer
                [$returnType, 'decode'],
                # Metadata
                (array) $ctx->getValue('metadata'),
                # Options
                (array) $ctx->getValue('options'),
            ],
        );
        $callContext = Helper::withConnections($callContext, $this->connections);


        return $this->handler->handle($callContext);
    }

    /**
     * Execute gRPC call after the interceptor pipeline.
     *
     * If a load balancing or connection pooling is required, it should be implemented in an interceptor.
     *
     * @param non-empty-string $method
     */
    private function _invoke(
        ConnectionInterface $connection,
        string $method,
        Message $in,
        callable $deserializer,
        array $metadata,
        array $options,
    ): mixed {
        return $connection->getStub()->invoke($method, $in, $deserializer, $metadata, $options);
    }
}
